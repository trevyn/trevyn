General inspiration: https://en.wikipedia.org/wiki/Social_peer-to-peer_processes

Here's some little app experiments:

- [trevyn/notesearch](https://github.com/trevyn/notesearch)

Past movements:

- [trevyn/equipotent](https://github.com/trevyn/equipotent)
- [trevyn/turbo](https://github.com/trevyn/turbo)
- [turbo-historical](https://github.com/trevyn/turbo-historical)

## [__Turbocharger__](https://github.com/trevyn/turbocharger)

provides autogenerated async RPC bindings that instantly connect a JS frontend to a Rust backend service via WebSockets and WASM. Get started by using the turnkey [turbocharger-template](https://github.com/trevyn/turbocharger-template/generate), which adds Turbosql, Svelte, Tailwind, and Snowpack.

It makes a Rust _backend_ function, e.g.:

```rust
#[turbocharger::backend]
async fn get_person(id: i64) -> Person {
 Person { name: "Bob", age: 21 }
}
```

instantly available, with _no additional boilerplate_, to a frontend:

```js
let person = await backend.get_person(1);
```

## [__Turbosql__](https://github.com/trevyn/turbosql)

works great with Turbocharger; it's an easy local data persistence layer for Rust, backed by SQLite:

```rust
#[derive(Turbosql)]
struct Person {
 rowid: Option<i64>,
 name: Option<String>,
}

let rowid = Person {
 rowid: None,
 name: Some("Joe".to_string()),
}.insert()?;

let person = select!(Person "WHERE name = ?", "Joe")?;
execute!("UPDATE person SET age = ? WHERE name = ?", 18, "Joe")?;
execute!("DELETE FROM person WHERE rowid = ?", 1)?;
```
